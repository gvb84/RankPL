package com.tr.rp.ast.statements;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;

import com.tr.rp.ast.AbstractStatement;
import com.tr.rp.ast.Function;
import com.tr.rp.ast.LanguageElement;
import com.tr.rp.exceptions.RPLException;
import com.tr.rp.exceptions.RPLMiscException;
import com.tr.rp.iterators.ranked.DuplicateRemovingIterator;
import com.tr.rp.iterators.ranked.ExecutionContext;
import com.tr.rp.iterators.ranked.InitialVarStoreIterator;
import com.tr.rp.iterators.ranked.MarginalizingIterator;
import com.tr.rp.iterators.ranked.RankedIterator;
import com.tr.rp.iterators.ranked.RestrictIterator;
import com.tr.rp.ranks.FunctionScope;
import com.tr.rp.varstore.VarStore;

public class Program extends AbstractStatement {

	private final AbstractStatement body;
	private final FunctionScope functionScope;
	
	public Program(AbstractStatement body, FunctionScope functionScope) {
		this.body = body;
		this.functionScope = functionScope;
	}
	
	@Override
	public RankedIterator<VarStore> getIterator(RankedIterator<VarStore> parent, ExecutionContext c) throws RPLException {
		// Execute body, then main
		if (functionScope.hasFunction("main")) {
			Function f = functionScope.getFunction("main");
			if (f.getParameters().length != 0) {
				throw new RPLMiscException("The main function should have zero parameters.");
			}
			return f.getBody().getIterator(body.getIterator(parent, c), c);
		} else {
			return body.getIterator(parent, c);
		}
	}

	@Override
	public void getVariables(Set<String> list) {
		// nop
	}

	@Override
	public LanguageElement replaceVariable(String a, String b) {
		return this;
	}

	@Override
	public AbstractStatement rewriteEmbeddedFunctionCalls() {
		return this;
	}

	public String toString() {
		return body.toString();
	}
	
	/**
	 * Run program. Returns a ranked iterator that produces the values returned
	 * by this program's return statement. If there is no return statement, no
	 * values are returned.
	 */
	public RankedIterator<String> run(ExecutionContext c) throws RPLException {
		RankedIterator<VarStore> i = getIterator(new InitialVarStoreIterator(), c);
		final MarginalizingIterator mi = new MarginalizingIterator(i, "$return");
		return new RankedIterator<String>() {

			@Override
			public boolean next() throws RPLException {
				while (mi.next()) {
					if (mi.getItem().containsVar("$return")) {
						return true;
					}
				}
				return false;
			}

			@Override
			public String getItem() throws RPLException {
				VarStore v = mi.getItem();
				return v.getValue("$return").toString();
			}

			@Override
			public int getRank() {
				return mi.getRank();
			}
			
		};
	}
	
	/**
	 * Run program with iterative deepening.
	 * 
	 * @param c Execution context
	 * @param maxRank Maximum cut-off to execute
	 * @return The rank-zero results generated by this program
	 * @throws RPLException
	 */
	public RankedIterator<String> runWithIterativeDeepening(ExecutionContext c, int minCutOff, int maxCutOff) throws RPLException {
		
		c.setDestructiveJConditioning(true);
		c.setDestructiveLConditioning(true);
		
		RankedIterator<String> it = new RankedIterator<String>() {

			private Set<String> previousResults = new LinkedHashSet<String>();
			private Set<String> currentResults = new LinkedHashSet<String>();
			
			private int depth = minCutOff;

			private RankedIterator<String> currentRun; 

			@Override
			public boolean next() throws RPLException {
				if (currentRun.next()) {
					currentResults.add(getItem());
					return true;
				} else {

					// Check consistency
					checkConsistency();

					// If previous run did not register cut-off, we're done
					if (c.getMaxCutOff() == -1) {
						return false;
					}
					
					// Set up next run
					while (depth <= maxCutOff) {
						// Reset stats
						c.resetStats();

						// Increase depth
						depth++;
						c.setRankCutOff(depth);

						// Run
						currentRun = new RestrictIterator<String>(run(c), 1);
						if (currentRun.next()) {
							currentResults.add(getItem());
							return true;
						}
						
						// If previous run returns no results but did not register cut-off, we're done
						if (c.getMaxCutOff() == -1) {
							return false;
						}
					
					}
				}
				return false;
			}

			@Override
			public String getItem() throws RPLException {
				return currentRun.getItem();
			}

			@Override
			public int getRank() {
				return currentRun.getRank();
			}
			
			public RankedIterator<String> init() throws RPLException {
				c.setRankCutOff(depth);
				currentRun = new RestrictIterator<String>(run(c), 1);
				return this;
			}

			/**
			 * Check if all results returned before last call of checkConsistency() are
			 * included in all results returned after last call of checkConsistency().
			 */
			public void checkConsistency() {
				for (String res: previousResults) {
					if (!currentResults.contains(res)) {
						System.out.println("Warning: " + res + " possibly incorrect.");
					}
				}
				previousResults.addAll(currentResults);
				currentResults.clear();
			}
		}.init();
		
		return new DuplicateRemovingIterator<String>(it);
	}


	public AbstractStatement getBody() {
		return body;
	}

	public void stop() {
		// TODO Auto-generated method stub
		
	}
	
	@Override
	public void getAssignedVariables(Set<String> variables) {
		getAssignedVariables(variables);
	}

	@Override
	public boolean equals(Object o) {
		return o instanceof Program &&
				((Program)o).body.equals(body) &&
				((Program)o).functionScope.equals(functionScope);
	}

	@Override
	public int hashCode() {
		return Objects.hash(body, functionScope);
	}	


}
